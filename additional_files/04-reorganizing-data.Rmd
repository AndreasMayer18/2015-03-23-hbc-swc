---
title: "Re-organizing data"
date: "03/03/2015"
output: html_document
layout: topic
minutes: 
---

> ## Learning Objectives
> * Subsetting data and reordering data
> * Matching elements of dataframes
> * Replacing values in row/vectors
> * Add/remove columns and rows


# Subsetting data

When analyzing data, though, we often want to look at partial statistics, such
as the maximum value of a variable per species or the average value per plot.

One way to do this is to select the data we want, and create a new temporary
array, using the `subset()` function. For instance, if we just want to look at
the samples of a specific celltype "typeA":

```{r, purl=FALSE}
subset(metadata, celltype == "typeA")
```

We can also subset using other [logical operators](http://www.statmethods.net/management/operators.html) in R. For example suppose we wanted to subset to keep only the WT samples from the typeA cells.

```{r, purl=FALSE}
subset(metadata, celltype == "typeA" & genotype == "WT")
```

Alternatively, we could try looking at only the first two replicates of each sample set. Here, we can use the less than operator since replicate is currently a numeric vector. Adding in the argument select allwos us to specify which columns to keep. Which columns are left?
```{r, purl=FALSE}
subset(metadata, replicate < 3, select = -replicate)
```


# Matching data 

Let's bring in our data matrix. The experimental design file is associated with RNA-Seq data. From the experiment we have three different data files that have been generated which can be found in the `/data` directory. We will be using the RPKM data for now. Load in this file similar to how we did for our metadata file.

```{r, echo=TRUE}
rpkm_data <- read.csv("data//counts.rpkm")
```

Take a look at the first few lines of the data matrix to see what's in there.

```{r, echo=TRUE}
head(rpkm_data)
```

It looks as if the sample names (header) are similar to the row names of our metadata file, but it's hard to tell since they are not in the  same order. We can do a quick check of the dimensions and see if the numbers match up. 

```{r, echo=TRUE}
dim(rpkm_data)
```

Do we have data for every sample that we have metadata? To do that we can use the `%in%` operator. Although lacking in [documentation](http://dr-k-lo.blogspot.com/2013/11/in-in-r-underused-in-operator.html) this operator is well used and quite useful. It will take a vector as input to the right and will evaluate each element to see if there is a match in the vector that follows on the right of the operator. For each element of vector on the right it will return a logical value. Take a look at the example below:

```{r, echo=TRUE}

A <- c(1,3,5,7,9,11)   # odd numbers
B <- c(2,4,6,8,10,12)  # even numbers

# test to see if any of A are in B
A %in% B
```

Since vector A is odd numbers and vector B is even numbers, there is no overlap and so for each element we get a `FALSE`. Let's change a couple of numbers inside vector B.

```{r, echo=TRUE}

B <- c(2,4,6,8,1,5)  # add some odd numbers in 

# test to see if any of A are in B
A %in% B
```

The logical vector returned will tell us which elements are mismatching and we can count how many are `TRUE`. This example is a small vector and so it's easy to count; when we work with large datasets this is not pratcical. The `all` function comes in handy here. Given a logical vector, it will tell you whether are all values `TRUE`. If there is atleast one `FALSE` value, the function will return a `FALSE` and you know that all of A are not contained in B.

```{r, echo=TRUE}

all(A %in% B)
```

Suppose we had two vectors that had teh same values but just not in the same order. We could also use `all` to test for that. Rather tahn using the `%in%` operator we would use `==` and compare each element to the respective element in the other vector. Unlike the `%in%` operator, for this to work you must have two vectors that are of equal length.

```{r, echo=TRUE}

A <- c(1,2,3,4,5)
B <- c(5,4,3,2,1)  # same numbers but backwards 

# test to see if any of A are in B
A %in% B

# test to see if any of A is equal to B
A == B

# use all to check if they are a perfect match
all(A == B)
```

### Exercise
Apply the `all` function to check whether all of the row names of our metadata are contained in the header of our data file. Also check to see that tehy are in the same order.



### Challenge

1. What does the following do?

  ```{r, echo=FALSE, purl=TRUE}
  ## What does the following do? (Try to guess without executing it)
  ## surveys_DO$month[2] <- 8
  ```

1. Use the function `subset` twice to create a `data.frame` that contains all
individuals of the species "DM" that were collected in 2002.
  * How many individuals of the species "DM" were collected in 2002?

  ```{r, echo=FALSE, purl=TRUE}
  ##  Use the function `subset` twice to create a `data.frame` that
  ##  contains all individuals of the species "DM" that were collected
  ##  in 2002.
  ##   * How many individuals of the species "DM" were collected in 2002?
  ```

## Adding a column to our dataset

```{r, echo=FALSE, purl=TRUE}
## Adding columns
```

Sometimes, you may have to add a new column to your dataset that represents a
new variable. You can add columns to a `data.frame` using the function `cbind()`
(__c__olumn __bind__). Beware, the additional column must have the same number
of elements as there are rows in the `data.frame`.

In our survey dataset, the species are represented by a 2-letter code (e.g.,
"AB"), however, we would like to include the species name. The correspondance
between the 2 letter code and the names are in the file `species.csv`. In this
file, one column includes the genus and another includes the species. First, we
are going to import this file in memory:

```{r, echo=FALSE, purl=FALSE}
species <- read.csv("../../data/biology/species.csv")
```

```{r, eval=FALSE, purl=TRUE}
species <- read.csv("data/species.csv")
```

We are then going to use the function `match()` to create a vector that contains
the genus names for all our observations. The function `match()` takes at least
2 arguments: the values to be matched (in our case the 2 letter code from the
`surveys` data frame held in the column `species`), and the table that contains
the values to be matched against (in our case the 2 letter code in the `species`
data frame held in the column `species_id`). The function returns the position
of the matches in the table, and this can be used to retrieve the genus names:

```{r, purl=TRUE}
surveys_spid_index <- match(surveys$species, species$species_id)
surveys_genera <- species$genus[surveys_spid_index]
```

Now that we have our vector of genus names, we can add it as a new column to our
`surveys` object:

```{r, purl=TRUE}
surveys <- cbind(surveys, genus=surveys_genera)
```

### Challenge

Use the same approach to also include the species names in the `surveys` data
frame.

```{r, echo=FALSE, purl=TRUE}
## Use the same approach to also include the species names in the
## `surveys` data frame.
```


```{r, echo=FALSE, purl=FALSE}
surveys_species <- species$species[surveys_spid_index]
surveys <- cbind(surveys, species_name=surveys_species)
```

```{r, results='show'}
## and check out the result
head(surveys)
```

<!--- should we cover merge()? --->

# Adding rows

<!--- Even if this is not optimal, using this approach requires to cover less   -->
<!--- material such as logical operations on vectors. Depending on how fast the -->
<!--- group moves, it might be better to show the correct way.                  -->

```{r, echo=FALSE, purl=TRUE}
## Adding rows
```

Let's create a `data.frame` that contains the information only for the species
"DO" and "DM". We know how to create the data set for each species with the
function `subset()`:

```{r, purl=FALSE}
surveys_DO <- subset(surveys, species == "DO")
surveys_DM <- subset(surveys, species == "DM")
```

Similarly to `cbind()` for columns, there is a function `rbind()` (__r__ow
__bind__) that puts together two `data.frame`. With `rbind()` the number of
columns and their names must be identical between the two objects:

```{r, purl=FALSE}
surveys_DO_DM <- rbind(surveys_DO, surveys_DM)
```

### Challenge

Using a similar approach, construct a new `data.frame` that only includes data
for the years 2000 and 2001.

```{r, echo=FALSE, purl=TRUE}
## How many columns are now in (1) the `data.frame` `surveys`, (2) the `data.frame`
## `surveys_index`?
```

# Removing columns

```{r, echo=FALSE, purl=FALSE}
## Removing columns
```

Just like you can select columns by their positions in the `data.frame` or by
their names, you can remove them similarly.

To remove it by column number:

```{r, results='show', purl=FALSE}
surveys_noDate <- surveys[, -c(2:4)]
colnames(surveys)
colnames(surveys_noDate)
```

The easiest way to remove by name is to use the `subset()` function. This time
we need to specify explicitly the argument `select` as the default is to subset
on rows (as above). The minus sign indicates the names of the columns to remove
(note that the column names should not be quoted):

```{r, results='show', purl=FALSE}
surveys_noDate2 <- subset(surveys, select=-c(month, day, year))
colnames(surveys_noDate2)
```

# Removing rows

```{r, echo=FALSE, purl=FALSE}
## Removing rows
```

Typically rows are not associated with names, so to remove them from the
`data.frame`, you can do:

```{r, results='show', purl=FALSE}
surveys_missingRows <- surveys[-c(10, 50:70), ] # removing rows 10, and 50 to 70
```
