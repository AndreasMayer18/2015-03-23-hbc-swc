---
title: "Re-organizing data"
date: "03/03/2015"
output: html_document
layout: topic
minutes: 
---

> ## Learning Objectives
> * Subsetting data and reordering data
> * Matching elements of dataframes
> * Replacing values in row/vectors
> * Add/remove columns and rows


# Subsetting data

When analyzing data, we often want to look at partial statistics, such
as the maximum value of a variable per species or the average value per plot.

One way to do this is to select the data we want, and create a new temporary
array, using the `subset()` function. For instance, if we just want to look at
the samples of a specific celltype "typeA":

```{r, purl=FALSE}
subset(metadata, celltype == "typeA")
```

We can also subset using other [logical operators](http://www.statmethods.net/management/operators.html) in R. For example suppose we wanted to subset to keep only the **WT samples** from the **typeA cells**.

```{r, purl=FALSE}
subset(metadata, celltype == "typeA" & genotype == "WT")
```

Alternatively, we could try looking at only the first two replicates of each sample set. Here, we can use the less than operator since replicate is currently a numeric vector. Adding in the argument select allwos us to specify which columns to keep. Which columns are left?
```{r, purl=FALSE}
subset(metadata, replicate < 3, select = c('genotype', 'celltype'))
       
```


# Matching data 

Let's bring in our data matrix. The experimental design file is associated with RNA-Seq data. From the experiment we have three different data files that have been generated which can be found in the `/data` directory. We will be using the RPKM data for now. Load in this file similar to how we did for our metadata file.

```{r, echo=TRUE}
rpkm_data <- read.csv("data//counts.rpkm")
```

Take a look at the first few lines of the data matrix to see what's in there.

```{r, echo=TRUE}
head(rpkm_data)
```

It looks as if the sample names (header) are similar to the row names of our metadata file, but it's hard to tell since they are not in the  same order. We can do a quick check of the dimensions and see if the numbers match up. 

```{r, echo=TRUE}
dim(rpkm_data)
```

**Do we have data for every sample that we have metadata?** To do that we can use the `%in%` operator. Although lacking in [documentation](http://dr-k-lo.blogspot.com/2013/11/in-in-r-underused-in-operator.html) this operator is well used and quite useful. It will take a vector as input to the left and will evaluate each element to see if there is a match in the vector that follows on the right of the operator. For each element of vector on the left it will return a logical value. Take a look at the example below:

```{r, echo=TRUE}

A <- c(1,3,5,7,9,11)   # odd numbers
B <- c(2,4,6,8,10,12)  # even numbers

# test to see if any of A are in B
A %in% B
```

Since vector A is odd numbers and vector B is even numbers, there is no overlap and so for each element we get a `FALSE`. Let's change a couple of numbers inside vector B to match vector A.

```{r, echo=TRUE}

B <- c(2,4,6,8,1,5)  # add some odd numbers in 

# test to see if any of A are in B
A %in% B
```

The logical vector returned will tell us which elements are mismatching and we can count how many are `TRUE` to get an overlap. The two vectors do not have to be the same size. In this example the vectors are small and so it's easy to count; but when we work with large datasets this is not practical. The `all` function comes in handy here. Given a logical vector, it will tell you whether are all values returned are `TRUE`. If there is atleast one `FALSE` value, the `all` function will return a `FALSE` and you know that all of A are not contained in B.

```{r, echo=TRUE}

all(A %in% B)
```

Suppose we had **two vectors that had the same values but just not in the same order**. We could also use `all` to test for that. Rather than using the `%in%` operator we would use `==` and compare each element to the same position in the other vector. Unlike the `%in%` operator, for this to work you must have **two vectors that are of equal length**.

```{r, echo=TRUE}

A <- c(1,2,3,4,5)
B <- c(5,4,3,2,1)  # same numbers but backwards 

# test to see if any of A are in B
A %in% B

# test to see if any of A is equal to B
A == B

# use all to check if they are a perfect match
all(A == B)
```

### Exercise
Apply the `all` function to check whether all of the row names of our metadata are contained in the header of our data file. Also check to see that they are in the same order.


## Subset data using matching
The column names in our data matrix are all contained in the row names of our metadata, but they appear to be out of order. We can use the `match()` function to create a new data matrix such that samples are in the same order. The function `match()` takes at least
2 arguments: the values to be matched (in our case the row names `metadata`), and the table that contains the values to be matched against (in our case the column names of `data`. The function returns the position of the matches in the table, and this can be used to data columns. For values that don't match you can specify what values you would have it assigned using `nomatch` argument (by default this is NA).


```{r, echo=FALSE}
# Retrieve a vector of indices where the column names match the row names 
m <- match(row.names(metadata), colnames(data))

# Create a re-ordered data matrix based on the matching indices
data_ordered  <- data[,m]

# Check and see what happened
head(data_ordered)

# Verify that the two are identical in order
all(row.names(metadata) == colnames(data_ordered))
```


# Modifying `data.frames`

Sometimes, you may have to add a new column to your dataset that represents a
new variable. You can add columns to a `data.frame` using the function `cbind()`
(__c__olumn __bind__). Beware, the additional column must have the same number
of elements as there are rows in the `data.frame`.

The data matrix we are working with has Ensembl IDs as the identifier, however it would also be nice to know the official gene symbols assocated with those IDs. The gene annotation was only provided for the counts file (`data/annotated_combined.counts`) but not the RPKM data. We need to take the gene symbols from the counts file and add it as a column in our data matrix. 

### Exercise
First you will use what you have learned previously to read in the file and check to make see if:

1. all of the Ensemble IDs in the count matrix are contained in the RPKM matrix
2. the order of Ensemble Ids is the same in both data frames

```{r, echo=FALSE}

# Answer to exercise
counts <- read.csv('data/annotated_combined.counts')

head(counts) # take a peek inside

all(row.names(data) %in% row.names(counts))
all(row.names(data) == row.names(counts))    # this will give an error

# There is a difference in dimensions
dim(counts)
dim(data)

```

Upon completion of the exercise, what did you find out? 

You should have noticesHere we intoduce `which` as another function to subset. to subset, then match to reorder (if needed)

then cbind to add columns, and show them how to remove it from the counts file. text only for rbind

Use the same approach to also include the species names in the `surveys` data
frame.

```{r, echo=FALSE, purl=TRUE}
## Use the same approach to also include the species names in the
## `surveys` data frame.
```


```{r, echo=FALSE, purl=FALSE}
surveys_species <- species$species[surveys_spid_index]
surveys <- cbind(surveys, species_name=surveys_species)
```

```{r, results='show'}
## and check out the result
head(surveys)
```

<!--- should we cover merge()? --->

# Adding rows

<!--- Even if this is not optimal, using this approach requires to cover less   -->
<!--- material such as logical operations on vectors. Depending on how fast the -->
<!--- group moves, it might be better to show the correct way.                  -->

```{r, echo=FALSE, purl=TRUE}
## Adding rows
```

Let's create a `data.frame` that contains the information only for the species
"DO" and "DM". We know how to create the data set for each species with the
function `subset()`:

```{r, purl=FALSE}
surveys_DO <- subset(surveys, species == "DO")
surveys_DM <- subset(surveys, species == "DM")
```

Similarly to `cbind()` for columns, there is a function `rbind()` (__r__ow
__bind__) that puts together two `data.frame`. With `rbind()` the number of
columns and their names must be identical between the two objects:

```{r, purl=FALSE}
surveys_DO_DM <- rbind(surveys_DO, surveys_DM)
```

### Challenge

Using a similar approach, construct a new `data.frame` that only includes data
for the years 2000 and 2001.

```{r, echo=FALSE, purl=TRUE}
## How many columns are now in (1) the `data.frame` `surveys`, (2) the `data.frame`
## `surveys_index`?
```

# Removing columns

```{r, echo=FALSE, purl=FALSE}
## Removing columns
```

Just like you can select columns by their positions in the `data.frame` or by
their names, you can remove them similarly.

To remove it by column number:

```{r, results='show', purl=FALSE}
surveys_noDate <- surveys[, -c(2:4)]
colnames(surveys)
colnames(surveys_noDate)
```

The easiest way to remove by name is to use the `subset()` function. This time
we need to specify explicitly the argument `select` as the default is to subset
on rows (as above). The minus sign indicates the names of the columns to remove
(note that the column names should not be quoted):

```{r, results='show', purl=FALSE}
surveys_noDate2 <- subset(surveys, select=-c(month, day, year))
colnames(surveys_noDate2)
```

# Removing rows

```{r, echo=FALSE, purl=FALSE}
## Removing rows
```

Typically rows are not associated with names, so to remove them from the
`data.frame`, you can do:

```{r, results='show', purl=FALSE}
surveys_missingRows <- surveys[-c(10, 50:70), ] # removing rows 10, and 50 to 70
```
